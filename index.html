<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>縦書きグリッドエディタ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #fff;
            height: 100vh;
            overflow: hidden;
        }
        
        .editor-container {
            display: grid;
            grid-template-columns: 350px 1fr;
            height: 100vh;
        }
        
        /* 左側: コントロールパネル */
        .control-panel {
            background: #252525;
            border-right: 1px solid #333;
            overflow-y: auto;
            padding: 20px;
        }
        
        .control-panel h1 {
            font-size: 20px;
            margin-bottom: 20px;
            color: #4a9eff;
        }
        
        .section {
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 1px solid #333;
        }
        
        .section h2 {
            font-size: 14px;
            margin-bottom: 15px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            font-size: 13px;
            margin-bottom: 5px;
            color: #aaa;
        }
        
        .control-group input[type="text"],
        .control-group input[type="number"],
        .control-group input[type="color"],
        .control-group select,
        .control-group textarea {
            width: 100%;
            padding: 8px 12px;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 4px;
            color: #fff;
            font-size: 13px;
        }
        
        .control-group textarea {
            resize: vertical;
            min-height: 60px;
        }
        
        .control-group input[type="range"] {
            width: 100%;
        }
        
        .btn {
            padding: 10px 15px;
            background: #4a9eff;
            border: none;
            border-radius: 4px;
            color: white;
            cursor: pointer;
            font-size: 13px;
            width: 100%;
            margin-top: 10px;
        }
        
        .btn:hover {
            background: #3a8eef;
        }
        
        .btn-secondary {
            background: #555;
        }
        
        .btn-secondary:hover {
            background: #666;
        }
        
        .btn-danger {
            background: #e74c3c;
        }
        
        .btn-danger:hover {
            background: #c0392b;
        }
        
        /* 右側: プレビューエリア */
        .preview-area {
            background: #f5f5f5;
            overflow-y: auto;
            padding: 40px;
        }
        
        .preview-container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        /* グリッドアイテムのコントロール */
        .grid-item-control {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 15px;
        }
        
        .grid-item-control h3 {
            font-size: 14px;
            margin-bottom: 12px;
            color: #4a9eff;
        }
        
        .row-controls {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }
        
        .row-controls .btn {
            flex: 1;
            margin-top: 0;
            padding: 6px 10px;
            font-size: 12px;
        }
        
        .color-input-group {
            display: grid;
            grid-template-columns: 50px 1fr;
            gap: 8px;
            align-items: center;
        }
        
        input[type="color"] {
            height: 35px;
            cursor: pointer;
        }
        
        .range-value {
            display: inline-block;
            margin-left: 10px;
            color: #4a9eff;
            font-weight: 600;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .checkbox-group input[type="checkbox"] {
            width: auto;
        }
        
        /* プレビューのスタイル */
        .grid-row {
            display: grid;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .grid-item {
            border-radius: 8px;
            padding: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .grid-item.with-shadow {
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .grid-link {
            text-decoration: none;
            color: inherit;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .grid-link:hover {
            text-decoration: underline;
        }
        
        

        .grid-image {
            max-width: 100%;
            max-height: 100%;
            width: 100%;
            height: 100%;
            object-fit: contain;
            display: block;
            position: relative;
            z-index: 2;
        }

        .grid-content {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .grid-both {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .overlay-wrap {
            position: relative;
            width: 100%;
            height: 100%;
        }

        .overlay-text {
            position: absolute;
            z-index: 3;
            left: 50%;
            transform: translateX(-50%);
            pointer-events: none;
        }

        .overlay-top {
            top: 20px;
        }

        .overlay-center {
            top: 50%;
            transform: translate(-50%, -50%);
        }

        .overlay-bottom {
            bottom: 20px;
        }
        
        .vertical-text {
            writing-mode: vertical-rl;
            text-orientation: upright;
            white-space: nowrap;
        }
        
        .horizontal-text {
            writing-mode: horizontal-tb;
        }
        
        .mincho {
            font-family: "Yu Mincho", "YuMincho", "Hiragino Mincho Pro", "MS Mincho", serif;
        }
        
        .gothic {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Hiragino Sans", "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
        }
        
        /* エクスポートモーダル */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        
        .modal.active {
            display: flex;
        }
        
        .modal-content {
            background: #252525;
            padding: 30px;
            border-radius: 8px;
            max-width: 800px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .modal-content h2 {
            margin-bottom: 20px;
            color: #4a9eff;
        }
        
        .modal-content textarea {
            width: 100%;
            height: 400px;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 4px;
            color: #fff;
            padding: 15px;
            font-family: monospace;
            font-size: 12px;
        }
        
        .modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        /* リップルエフェクト */
        .ripple::before, .ripple::after {
            content: '';
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: transparent;
            border: 1px solid rgba(0, 0, 0, 0.6);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            animation: ripple-animation 2.5s ease-out forwards;
            z-index: 1;
        }
        
        .ripple::after {
            animation-delay: 0.5s;
        }
        
        @keyframes ripple-animation {
            0% {
                width: 40px;
                height: 40px;
                opacity: 0.8;
            }
            100% {
                width: 1500px;
                height: 1500px;
                opacity: 0;
            }
        }
        
        @media (max-width: 768px) {
            .grid-row {
                grid-template-columns: 1fr !important;
            }
        }
    </style>
</head>
<body>
    <div class="editor-container">
        <!-- 左側: コントロールパネル -->
        <div class="control-panel">
            <h1>縦書きグリッドエディタ</h1>
            
            <!-- グローバル設定 -->
            <div class="section">
                <h2>グローバル設定</h2>
                
                <div class="control-group">
                    <label>背景色</label>
                    <div class="color-input-group">
                        <input type="color" id="bg-color" value="#f5f5f5">
                        <input type="text" id="bg-color-text" value="#f5f5f5">
                    </div>
                </div>
                
                <div class="control-group">
                    <label>最大幅 (px)</label>
                    <input type="number" id="max-width" value="1200" min="400" max="2000">
                </div>

                <div class="control-group">
                    <div class="checkbox-group">
                        <input type="checkbox" id="shadow-enabled" checked>
                        <label for="shadow-enabled">グリッドに影を付ける</label>
                    </div>
                </div>
                
                <button class="btn" onclick="addRow()">+ 行を追加</button>
            </div>
            
            <!-- グリッドアイテムのコントロール -->
            <div class="section">
                <h2>グリッドアイテム</h2>
                <div id="grid-controls"></div>
            </div>
            
            <!-- エクスポート -->
            <div class="section">
                <h2>エクスポート</h2>
                <button class="btn" onclick="exportHTML()">HTMLをエクスポート</button>
                <button class="btn btn-secondary" onclick="loadTemplate()">テンプレート読込</button>
            </div>
        </div>
        
        <!-- 右側: プレビューエリア -->
        <div class="preview-area" id="preview-area">
            <div class="preview-container" id="preview"></div>
        </div>
    </div>
    
    <!-- エクスポートモーダル -->
    <div class="modal" id="export-modal">
        <div class="modal-content">
            <h2>HTMLコード</h2>
            <textarea id="export-code" readonly></textarea>
            <div class="modal-buttons">
                <button class="btn" onclick="copyHTML()">コピー</button>
                <button class="btn" onclick="downloadHTML()">ダウンロード</button>
                <button class="btn btn-secondary" onclick="closeModal()">閉じる</button>
            </div>
        </div>
    </div>
    
    <script>
        // グリッドデータ
        let gridData = {
            bgColor: '#f5f5f5',
            maxWidth: 1200,
            shadowEnabled: true,  // 影の有効/無効
            rows: []
        };
        
        let nextRowId = 1;
        
        // 初期化
        function init() {
            // カラーピッカーと連動
            document.getElementById('bg-color').addEventListener('input', (e) => {
                gridData.bgColor = e.target.value;
                document.getElementById('bg-color-text').value = e.target.value;
                updatePreview();
            });
            
            document.getElementById('bg-color-text').addEventListener('input', (e) => {
                gridData.bgColor = e.target.value;
                document.getElementById('bg-color').value = e.target.value;
                updatePreview();
            });
            
            document.getElementById('max-width').addEventListener('input', (e) => {
                gridData.maxWidth = parseInt(e.target.value);
                updatePreview();
            });

            // 影のトグル
            document.getElementById('shadow-enabled').addEventListener('change', (e) => {
                gridData.shadowEnabled = e.target.checked;
                updatePreview();
            });
            
            // 初期行を追加
            addRow();
        }
        
        // 行を追加
        function addRow() {
            const row = {
                id: nextRowId++,
                columns: 2,
                items: [
                    {
                        type: 'text',
                        imageUrl: '',
                        textPosition: 'center',
                        overlay: false,
                        text: 'サンプルテキスト',
                        aspectRatio: '1/1',
                        hasRipple: false,
                        color: '#333333',
                        fontSize: 24,
                        fontFamily: 'gothic',
                        isHorizontal: false,
                        borderWidth: 0,
                        borderColor: '#000000',
                        backgroundColor: '#ffffff',
                        link: '',
                        newTab: true
                    },
                    {
                        type: 'text',
                        imageUrl: '',
                        textPosition: 'center',
                        overlay: false,
                        text: 'サンプルテキスト',
                        aspectRatio: '1/1',
                        hasRipple: false,
                        color: '#333333',
                        fontSize: 24,
                        fontFamily: 'gothic',
                        isHorizontal: false,
                        borderWidth: 0,
                        borderColor: '#000000',
                        backgroundColor: '#ffffff',
                        link: '',
                        newTab: true
                    }
                ]
            };
            gridData.rows.push(row);
            renderControls();
            updatePreview();
        }
        
        // 行を削除
        function removeRow(rowId) {
            gridData.rows = gridData.rows.filter(r => r.id !== rowId);
            renderControls();
            updatePreview();
        }
        
        // 列を追加
        function addColumn(rowId) {
            const row = gridData.rows.find(r => r.id === rowId);
            if (!row) return;
            
            row.columns++;
            row.items.push({
                type: 'text',
                imageUrl: '',
                textPosition: 'center',
                overlay: false,
                text: 'サンプルテキスト',
                aspectRatio: '1/1',
                hasRipple: false,
                color: '#333333',
                fontSize: 24,
                fontFamily: 'gothic',
                isHorizontal: false,
                borderWidth: 0,
                borderColor: '#000000',
                backgroundColor: '#ffffff',
                link: '',
                newTab: true
            });
            renderControls();
            updatePreview();
        }
        
        // 列を削除
        function removeColumn(rowId) {
            const row = gridData.rows.find(r => r.id === rowId);
            if (!row || row.columns <= 1) return;
            
            row.columns--;
            row.items.pop();
            renderControls();
            updatePreview();
        }
        
        // コントロールをレンダリング
        function renderControls() {
            const container = document.getElementById('grid-controls');
            container.innerHTML = '';
            
            gridData.rows.forEach((row, rowIndex) => {
                const rowControl = document.createElement('div');
                rowControl.className = 'grid-item-control';
                rowControl.innerHTML = `
                    <h3>行 ${rowIndex + 1} (${row.columns}列)</h3>
                    <div class="row-controls">
                        <button class="btn" onclick="addColumn(${row.id})">+ 列</button>
                        <button class="btn btn-secondary" onclick="removeColumn(${row.id})">- 列</button>
                        <button class="btn btn-danger" onclick="removeRow(${row.id})">✕ 削除</button>
                    </div>
                `;
                
                row.items.forEach((item, itemIndex) => {
                    const itemControl = document.createElement('div');
                    itemControl.style.marginTop = '15px';
                    itemControl.style.paddingTop = '15px';
                    itemControl.style.borderTop = '1px solid #444';
                    
                    itemControl.innerHTML = `
                        <div style="margin-bottom: 10px; color: #4a9eff; font-weight: 600;">列 ${itemIndex + 1}</div>
                        
                        <div class="control-group">
                            <label>タイプ</label>
                            <select onchange="updateItemType(${row.id}, ${itemIndex}, this.value)">
                                <option value="text" ${item.type === 'text' ? 'selected' : ''}>テキストのみ</option>
                                <option value="image" ${item.type === 'image' ? 'selected' : ''}>画像のみ</option>
                                <option value="both" ${item.type === 'both' ? 'selected' : ''}>テキスト+画像</option>
                            </select>
                        </div>
                        
                        ${item.type !== 'image' ? `
                        <div class="control-group">
                            <label>テキスト</label>
                            <textarea oninput="updateItemText(${row.id}, ${itemIndex}, this.value)">${item.text}</textarea>
                        </div>
                        
                        <div class="control-group">
                            <label>テキスト色</label>
                            <div class="color-input-group">
                                <input type="color" value="${item.color}" onchange="updateItemColor(${row.id}, ${itemIndex}, this.value)">
                                <input type="text" value="${item.color}" oninput="updateItemColor(${row.id}, ${itemIndex}, this.value)">
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <label>フォントサイズ <span class="range-value">${item.fontSize}px</span></label>
                            <input type="range" min="12" max="72" value="${item.fontSize}" oninput="updateItemFontSize(${row.id}, ${itemIndex}, this.value)">
                        </div>
                        
                        <div class="control-group">
                            <label>フォント</label>
                            <select onchange="updateItemFontFamily(${row.id}, ${itemIndex}, this.value)">
                                <option value="gothic" ${item.fontFamily === 'gothic' ? 'selected' : ''}>ゴシック</option>
                                <option value="mincho" ${item.fontFamily === 'mincho' ? 'selected' : ''}>明朝</option>
                            </select>
                        </div>
                        
                        <div class="control-group">
                            <div class="checkbox-group">
                                <input type="checkbox" id="horizontal-${row.id}-${itemIndex}" ${item.isHorizontal ? 'checked' : ''} onchange="updateItemHorizontal(${row.id}, ${itemIndex}, this.checked)">
                                <label for="horizontal-${row.id}-${itemIndex}">横書きにする</label>
                            </div>
                        </div>
                        ` : ''}
                        
                        ${item.type !== 'text' ? `
                        <div class="control-group">
                            <label>画像URL</label>
                            <input type="text" value="${item.imageUrl}" oninput="updateItemImageUrl(${row.id}, ${itemIndex}, this.value)">
                        </div>
                        ` : ''}
                        
                        ${item.type === 'both' ? `
                        <div class="control-group">
                            <div class="checkbox-group">
                                <input type="checkbox" id="overlay-${row.id}-${itemIndex}" ${item.overlay ? 'checked' : ''} onchange="updateItemOverlay(${row.id}, ${itemIndex}, this.checked)">
                                <label for="overlay-${row.id}-${itemIndex}">画像上にテキストを重ねる</label>
                            </div>
                        </div>
                        
                        ${item.overlay ? `
                        <div class="control-group">
                            <label>テキスト位置</label>
                            <select onchange="updateItemTextPosition(${row.id}, ${itemIndex}, this.value)">
                                <option value="top" ${item.textPosition === 'top' ? 'selected' : ''}>上</option>
                                <option value="center" ${item.textPosition === 'center' ? 'selected' : ''}>中央</option>
                                <option value="bottom" ${item.textPosition === 'bottom' ? 'selected' : ''}>下</option>
                            </select>
                        </div>
                        ` : `
                        <div class="control-group">
                            <label>テキスト位置</label>
                            <select onchange="updateItemTextPosition(${row.id}, ${itemIndex}, this.value)">
                                <option value="top" ${item.textPosition === 'top' ? 'selected' : ''}>上</option>
                                <option value="center" ${item.textPosition === 'center' ? 'selected' : ''}>中央</option>
                                <option value="bottom" ${item.textPosition === 'bottom' ? 'selected' : ''}>下</option>
                            </select>
                        </div>
                        `}
                        ` : ''}
                        
                        <div class="control-group">
                            <label>アスペクト比</label>
                            <select id="aspect-select-${row.id}-${itemIndex}" onchange="updateItemAspectRatio(${row.id}, ${itemIndex}, this.value)">
                                <option value="1/1" ${item.aspectRatio === '1/1' ? 'selected' : ''}>正方形 (1:1)</option>
                                <option value="16/9" ${item.aspectRatio === '16/9' ? 'selected' : ''}>横長 (16:9)</option>
                                <option value="4/3" ${item.aspectRatio === '4/3' ? 'selected' : ''}>横長 (4:3)</option>
                                <option value="3/4" ${item.aspectRatio === '3/4' ? 'selected' : ''}>縦長 (3:4)</option>
                                <option value="9/16" ${item.aspectRatio === '9/16' ? 'selected' : ''}>縦長 (9:16)</option>
                                <option value="custom" ${!['1/1','16/9','4/3','3/4','9/16'].includes(item.aspectRatio) ? 'selected' : ''}>カスタム</option>
                            </select>
                        </div>
                        
                        <div class="control-group" id="custom-aspect-${row.id}-${itemIndex}" style="display: ${!['1/1','16/9','4/3','3/4','9/16'].includes(item.aspectRatio) ? 'block' : 'none'};">
                            <label>カスタム比率 (幅 : 高さ)</label>
                            <div style="display: grid; grid-template-columns: 1fr auto 1fr; gap: 8px; align-items: center;">
                                <input type="number" id="aspect-w-${row.id}-${itemIndex}" min="1" value="${item.aspectRatio.split('/')[0] || 1}" oninput="updateCustomAspect(${row.id}, ${itemIndex})">
                                <span style="color: #aaa;">:</span>
                                <input type="number" id="aspect-h-${row.id}-${itemIndex}" min="1" value="${item.aspectRatio.split('/')[1] || 1}" oninput="updateCustomAspect(${row.id}, ${itemIndex})">
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <label>枠線の太さ (px)</label>
                            <input type="number" min="0" max="10" value="${item.borderWidth}" oninput="updateItemBorderWidth(${row.id}, ${itemIndex}, this.value)">
                        </div>
                        
                        <div class="control-group">
                            <label>枠線の色</label>
                            <div class="color-input-group">
                                <input type="color" value="${item.borderColor}" onchange="updateItemBorderColor(${row.id}, ${itemIndex}, this.value)">
                                <input type="text" value="${item.borderColor}" oninput="updateItemBorderColor(${row.id}, ${itemIndex}, this.value)">
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <label>背景色</label>
                            <div class="color-input-group">
                                <input type="color" value="${item.backgroundColor || '#ffffff'}" onchange="updateItemBackgroundColor(${row.id}, ${itemIndex}, this.value)">
                                <input type="text" value="${item.backgroundColor || '#ffffff'}" oninput="updateItemBackgroundColor(${row.id}, ${itemIndex}, this.value)">
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <div class="checkbox-group">
                                <input type="checkbox" id="ripple-${row.id}-${itemIndex}" ${item.hasRipple ? 'checked' : ''} onchange="updateItemRipple(${row.id}, ${itemIndex}, this.checked)">
                                <label for="ripple-${row.id}-${itemIndex}">リップルエフェクト</label>
                            </div>
                        </div>

                        <div class="control-group">
                            <label>リンクURL (オプション)</label>
                            <input type="text" value="${item.link || ''}" oninput="updateItemLink(${row.id}, ${itemIndex}, this.value)" placeholder="https://example.com">
                        </div>

                        ${item.link ? `
                        <div class="control-group">
                            <div class="checkbox-group">
                                <input type="checkbox" id="newtab-${row.id}-${itemIndex}" ${item.newTab !== false ? 'checked' : ''} onchange="updateItemNewTab(${row.id}, ${itemIndex}, this.checked)">
                                <label for="newtab-${row.id}-${itemIndex}">新しいタブで開く</label>
                            </div>
                        </div>
                        ` : ''}
                    `;
                    
                    rowControl.appendChild(itemControl);
                });
                
                container.appendChild(rowControl);
            });
        }
        
        // プレビュー更新
        function updatePreview() {
            const preview = document.getElementById('preview');
            const previewArea = document.getElementById('preview-area');
            
            previewArea.style.background = gridData.bgColor;
            preview.style.maxWidth = gridData.maxWidth + 'px';
            
            preview.innerHTML = '';
            
            gridData.rows.forEach(row => {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'grid-row';
                rowDiv.style.gridTemplateColumns = `repeat(${row.columns}, 1fr)`;
                
                row.items.forEach(item => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'grid-item';
                    
                    // 影の適用
                    if (gridData.shadowEnabled) {
                        itemDiv.classList.add('with-shadow');
                    }
                    
                    if (item.hasRipple) {
                        itemDiv.classList.add('ripple');
                    }
                    itemDiv.style.aspectRatio = item.aspectRatio;
                    itemDiv.style.border = `${item.borderWidth}px solid ${item.borderColor}`;
                    itemDiv.style.background = item.backgroundColor || '#ffffff';
                    
                    let content = '';
                    
                    if (item.type === 'text') {
                        const fontClass = item.fontFamily === 'mincho' ? 'mincho' : 'gothic';
                        const textClass = item.isHorizontal ? 'horizontal-text' : 'vertical-text';
                        const justifyMap = { top: 'flex-start', center: 'center', bottom: 'flex-end' };
                        const justify = justifyMap[item.textPosition] || 'center';
                        
                        content = `
                            <div class="grid-content" style="justify-content: ${justify};">
                                <div class="${textClass} ${fontClass}" style="color: ${item.color}; font-size: ${item.fontSize}px;">
                                    ${item.text}
                                </div>
                            </div>
                        `;
                    } else if (item.type === 'image') {
                        content = `
                            <div class="grid-content">
                                <img class="grid-image" src="${item.imageUrl}" alt="">
                            </div>
                        `;
                    } else if (item.type === 'both') {
                        const fontClass = item.fontFamily === 'mincho' ? 'mincho' : 'gothic';
                        const textClass = item.isHorizontal ? 'horizontal-text' : 'vertical-text';
                        const justifyMap = { top: 'flex-start', center: 'center', bottom: 'flex-end' };
                        const justify = justifyMap[item.textPosition] || 'center';
                        
                        if (item.overlay) {
                            const overlayPos = item.textPosition || 'center';
                            content = `
                                <div class="overlay-wrap">
                                    <img class="grid-image" src="${item.imageUrl}" alt="">
                                    <div class="overlay-text overlay-${overlayPos}">
                                        <div class="${textClass} ${fontClass}" style="color: ${item.color}; font-size: ${item.fontSize}px;">
                                            ${item.text}
                                        </div>
                                    </div>
                                </div>
                            `;
                        } else {
                            content = `
                                <div class="grid-both" style="justify-content: ${justify};">
                                    <div class="${textClass} ${fontClass}" style="color: ${item.color}; font-size: ${item.fontSize}px;">
                                        ${item.text}
                                    </div>
                                    <img class="grid-image" src="${item.imageUrl}" alt="">
                                </div>
                            `;
                        }
                    }
                    
                    if (item.link) {
                        const targetAttrs = (item.newTab !== false) ? ' target="_blank" rel="noopener noreferrer"' : '';
                        itemDiv.innerHTML = `<a class="grid-link" href="${item.link}"${targetAttrs}>${content}</a>`;
                    } else {
                        itemDiv.innerHTML = content;
                    }
                    
                    rowDiv.appendChild(itemDiv);
                });
                
                preview.appendChild(rowDiv);
            });
        }
        
        // 更新関数
        function updateItemType(rowId, itemIndex, value) {
            const row = gridData.rows.find(r => r.id === rowId);
            row.items[itemIndex].type = value;
            renderControls();
            updatePreview();
        }
        
        function updateItemText(rowId, itemIndex, value) {
            const row = gridData.rows.find(r => r.id === rowId);
            row.items[itemIndex].text = value;
            updatePreview();
        }
        
        function updateItemColor(rowId, itemIndex, value) {
            const row = gridData.rows.find(r => r.id === rowId);
            row.items[itemIndex].color = value;
            renderControls();
            updatePreview();
        }
        
        function updateItemFontSize(rowId, itemIndex, value) {
            const row = gridData.rows.find(r => r.id === rowId);
            row.items[itemIndex].fontSize = parseInt(value);
            renderControls();
            updatePreview();
        }
        
        function updateItemFontFamily(rowId, itemIndex, value) {
            const row = gridData.rows.find(r => r.id === rowId);
            row.items[itemIndex].fontFamily = value;
            updatePreview();
        }
        
        function updateItemHorizontal(rowId, itemIndex, value) {
            const row = gridData.rows.find(r => r.id === rowId);
            row.items[itemIndex].isHorizontal = value;
            updatePreview();
        }
        
        function updateItemImageUrl(rowId, itemIndex, value) {
            const row = gridData.rows.find(r => r.id === rowId);
            row.items[itemIndex].imageUrl = value;
            updatePreview();
        }
        
        function updateItemOverlay(rowId, itemIndex, value) {
            const row = gridData.rows.find(r => r.id === rowId);
            row.items[itemIndex].overlay = value;
            renderControls();
            updatePreview();
        }
        
        function updateItemTextPosition(rowId, itemIndex, value) {
            const row = gridData.rows.find(r => r.id === rowId);
            row.items[itemIndex].textPosition = value;
            updatePreview();
        }
        
        function updateItemAspectRatio(rowId, itemIndex, value) {
            const row = gridData.rows.find(r => r.id === rowId);
            
            // カスタム入力の表示/非表示を切り替え
            const customDiv = document.getElementById(`custom-aspect-${rowId}-${itemIndex}`);
            
            if (value === 'custom') {
                customDiv.style.display = 'block';
                // カスタム入力フィールドから値を取得
                const w = document.getElementById(`aspect-w-${rowId}-${itemIndex}`).value;
                const h = document.getElementById(`aspect-h-${rowId}-${itemIndex}`).value;
                row.items[itemIndex].aspectRatio = `${w}/${h}`;
            } else {
                customDiv.style.display = 'none';
                row.items[itemIndex].aspectRatio = value;
            }
            
            updatePreview();
        }
        
        function updateCustomAspect(rowId, itemIndex) {
            const row = gridData.rows.find(r => r.id === rowId);
            const w = document.getElementById(`aspect-w-${rowId}-${itemIndex}`).value;
            const h = document.getElementById(`aspect-h-${rowId}-${itemIndex}`).value;
            row.items[itemIndex].aspectRatio = `${w}/${h}`;
            updatePreview();
        }
        
        function updateItemBorderWidth(rowId, itemIndex, value) {
            const row = gridData.rows.find(r => r.id === rowId);
            row.items[itemIndex].borderWidth = parseInt(value);
            updatePreview();
        }
        
        function updateItemBorderColor(rowId, itemIndex, value) {
            const row = gridData.rows.find(r => r.id === rowId);
            row.items[itemIndex].borderColor = value;
            renderControls();
            updatePreview();
        }
        
        function updateItemBackgroundColor(rowId, itemIndex, value) {
            const row = gridData.rows.find(r => r.id === rowId);
            row.items[itemIndex].backgroundColor = value;
            renderControls();
            updatePreview();
        }
        
        function updateItemRipple(rowId, itemIndex, value) {
            const row = gridData.rows.find(r => r.id === rowId);
            row.items[itemIndex].hasRipple = value;
            updatePreview();
        }

        function updateItemLink(rowId, itemIndex, value) {
            const row = gridData.rows.find(r => r.id === rowId);
            row.items[itemIndex].link = value;
            renderControls();
            updatePreview();
        }

        function updateItemNewTab(rowId, itemIndex, value) {
            const row = gridData.rows.find(r => r.id === rowId);
            row.items[itemIndex].newTab = value;
            updatePreview();
        }
        
        // HTMLエクスポート
        function exportHTML() {
            const shadowStyle = gridData.shadowEnabled 
                ? 'box-shadow: 0 2px 10px rgba(0,0,0,0.1);' 
                : '';

            let html = `<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>グリッドレイアウト</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: ${gridData.bgColor};
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            padding: 40px 20px;
        }
        
        .container {
            max-width: ${gridData.maxWidth}px;
            margin: 0 auto;
        }
        
        .grid-row {
            display: grid;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .grid-item {
            border-radius: 8px;
            padding: 20px;
            ${shadowStyle}
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .grid-link {
            text-decoration: none;
            color: inherit;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .grid-link:hover {
            text-decoration: underline;
        }

        .grid-image {
            max-width: 100%;
            max-height: 100%;
            width: 100%;
            height: 100%;
            object-fit: contain;
            display: block;
            position: relative;
            z-index: 2;
        }

        .grid-content {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .grid-both {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .overlay-wrap {
            position: relative;
            width: 100%;
            height: 100%;
        }

        .overlay-text {
            position: absolute;
            z-index: 3;
            left: 50%;
            transform: translateX(-50%);
            pointer-events: none;
        }

        .overlay-top {
            top: 20px;
        }

        .overlay-center {
            top: 50%;
            transform: translate(-50%, -50%);
        }

        .overlay-bottom {
            bottom: 20px;
        }
        
        .vertical-text {
            writing-mode: vertical-rl;
            text-orientation: upright;
            white-space: nowrap;
        }
        
        .horizontal-text {
            writing-mode: horizontal-tb;
        }
        
        .mincho {
            font-family: "Yu Mincho", "YuMincho", "Hiragino Mincho Pro", "MS Mincho", serif;
        }
        
        .gothic {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Hiragino Sans", "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
        }
        
        .ripple::before, .ripple::after {
            content: '';
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: transparent;
            border: 1px solid rgba(0, 0, 0, 0.6);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            animation: ripple-animation 2.5s ease-out forwards;
            z-index: 1;
        }
        
        .ripple::after {
            animation-delay: 0.5s;
        }
        
        @keyframes ripple-animation {
            0% {
                width: 40px;
                height: 40px;
                opacity: 0.8;
            }
            100% {
                width: 1500px;
                height: 1500px;
                opacity: 0;
            }
        }
        
        @media (max-width: 768px) {
            .grid-row {
                grid-template-columns: 1fr !important;
            }
        }
    </style>
</head>
<body>
    <div class="container">
`;
            
            gridData.rows.forEach(row => {
                html += `        <div class="grid-row" style="grid-template-columns: repeat(${row.columns}, 1fr);">\n`;
                row.items.forEach(item => {
                    const rippleClass = item.hasRipple ? ' ripple' : '';
                    const fontClass = item.fontFamily === 'mincho' ? ' mincho' : ' gothic';
                    const textClass = item.isHorizontal ? ' horizontal-text' : ' vertical-text';

                    const justifyMap = { top: 'flex-start', center: 'center', bottom: 'flex-end' };
                    const justify = justifyMap[item.textPosition] || 'center';

                    const safeText = (item.text ?? '').toString();
                    const safeImg = (item.imageUrl ?? '').toString();

                    const textInner = `<div class="${textClass}${fontClass}" style="color: ${item.color}; font-size: ${item.fontSize}px;">${safeText}</div>`;
                    const overlayPos = item.textPosition || 'center';
                    const overlayBox = `<div class="overlay-text overlay-${overlayPos}">${textInner}</div>`;
                    const textHtml = item.overlay ? overlayBox : textInner;

                    let content = '';
                    if (item.type === 'image') {
                        if (item.overlay) {
                            content = `<div class="overlay-wrap"><img class="grid-image" src="${safeImg}" alt="">${textHtml}</div>`;
                        } else {
                            content = `<div class="grid-content" style="justify-content:${justify};"><img class="grid-image" src="${safeImg}" alt=""></div>`;
                        }
                    } else if (item.type === 'both') {
                        if (item.overlay) {
                            content = `<div class="overlay-wrap"><img class="grid-image" src="${safeImg}" alt="">${textHtml}</div>`;
                        } else {
                            content = `<div class="grid-both" style="justify-content:${justify};">${textHtml}<img class="grid-image" src="${safeImg}" alt=""></div>`;
                        }
                    } else {
                        content = `<div class="grid-content" style="justify-content:${justify};">${textHtml}</div>`;
                    }

                    html += `            <div class="grid-item${rippleClass}" style="aspect-ratio: ${item.aspectRatio}; border: ${item.borderWidth}px solid ${item.borderColor}; background: ${item.backgroundColor || '#ffffff'};">
`;
                    if (item.link) {
                        const safeHref = item.link;
                        const targetAttrs = (item.newTab !== false) ? ' target="_blank" rel="noopener noreferrer"' : '';
                        html += `                <a class="grid-link" href="${safeHref}"${targetAttrs}>
`;
                    }
                    html += `                ${content}
`;
                    if (item.link) {
                        html += `                </a>
`;
                    }
                    html += `            </div>
`;
});
                html += `        </div>\n`;
            });
            
            html += `    </div>
</body>
</html>`;
            
            document.getElementById('export-code').value = html;
            document.getElementById('export-modal').classList.add('active');
        }
        
        // HTMLをコピー
        function copyHTML() {
            const textarea = document.getElementById('export-code');
            textarea.select();
            document.execCommand('copy');
            alert('HTMLをコピーしました!');
        }
        
        // HTMLをダウンロード
        function downloadHTML() {
            const html = document.getElementById('export-code').value;
            const blob = new Blob([html], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'grid-layout.html';
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // モーダルを閉じる
        function closeModal() {
            document.getElementById('export-modal').classList.remove('active');
        }
        
        // テンプレート読込
        function loadTemplate() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.html';
            input.onchange = (e) => {
                const file = e.target.files[0];
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        parseHTMLTemplate(event.target.result);
                    } catch (error) {
                        alert('HTMLの解析に失敗しました: ' + error.message);
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }
        
        // HTMLテンプレートを解析
        function parseHTMLTemplate(htmlString) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');
            
            // 背景色を取得
            const bgStyle = doc.body.style.background || '#f5f5f5';
            gridData.bgColor = bgStyle;
            document.getElementById('bg-color').value = bgStyle;
            document.getElementById('bg-color-text').value = bgStyle;
            
            // コンテナの最大幅を取得
            const container = doc.querySelector('.container');
            if (container) {
                const maxWidth = parseInt(container.style.maxWidth) || 1200;
                gridData.maxWidth = maxWidth;
                document.getElementById('max-width').value = maxWidth;
            }

            // 影の有無を判定
            const styleTag = doc.querySelector('style');
            if (styleTag) {
                const cssText = styleTag.textContent;
                const hasShadow = cssText.includes('box-shadow');
                gridData.shadowEnabled = hasShadow;
                document.getElementById('shadow-enabled').checked = hasShadow;
            }
            
            // グリッド行を解析
            const rows = doc.querySelectorAll('.grid-row');
            gridData.rows = [];
            
            rows.forEach(row => {
                const items = row.querySelectorAll('.grid-item');
                const rowData = {
                    id: nextRowId++,
                    columns: items.length,
                    items: []
                };
                
                items.forEach(item => {
                    const textEl = item.querySelector('.vertical-text, .horizontal-text');
                    const linkEl = item.querySelector('a.grid-link, a');
                    const imgEl = item.querySelector('img.grid-image, img');
                    const overlayWrap = item.querySelector('.overlay-wrap');
                    const link = linkEl ? (linkEl.getAttribute('href') || '') : '';
                    const newTab = linkEl ? ((linkEl.getAttribute('target') === '_blank') || (linkEl.getAttribute('rel') || '').includes('noopener')) : true;
                    
                    const text = textEl ? textEl.textContent : '';
                    const aspectRatio = item.style.aspectRatio || '1/1';
                    const hasRipple = item.classList.contains('ripple');
                    const color = textEl ? textEl.style.color || '#333' : '#333';
                    const fontSize = textEl ? parseInt(textEl.style.fontSize) || 24 : 24;
                    const borderWidth = parseInt(item.style.borderWidth) || 0;
                    const borderColor = item.style.borderColor || '#000000';
                    const backgroundColor = item.style.background || item.style.backgroundColor || '#ffffff';
                    const fontFamily = textEl && textEl.classList.contains('mincho') ? 'mincho' : 'gothic';
                    const isHorizontal = textEl && textEl.classList.contains('horizontal-text');

                    const imageUrl = imgEl ? (imgEl.getAttribute('src') || '') : '';
                    const overlay = !!overlayWrap || (textEl && textEl.classList.contains('overlay-text'));
                    let type = 'text';
                    if (imageUrl && text) type = 'both';
                    else if (imageUrl) type = 'image';
                    let textPosition = 'center';
                    const overlayBox = item.querySelector('.overlay-text');
                    if (overlayBox) {
                        if (overlayBox.classList.contains('overlay-top')) textPosition = 'top';
                        else if (overlayBox.classList.contains('overlay-bottom')) textPosition = 'bottom';
                        else if (overlayBox.classList.contains('overlay-center')) textPosition = 'center';
                    }

                    
                    rowData.items.push({
                        type,
                        imageUrl,
                        textPosition,
                        overlay,
                        text,
                        aspectRatio,
                        hasRipple,
                        color,
                        fontSize,
                        fontFamily,
                        isHorizontal,
                        borderWidth,
                        borderColor,
                        backgroundColor,
                        link,
                        newTab
                    });
                });
                
                gridData.rows.push(rowData);
            });
            
            renderControls();
            updatePreview();
            alert('テンプレートを読み込みました!');
        }
        
        // 初期化実行
        init();
    </script>
</body>
</html>
